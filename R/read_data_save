read_data <- shiny::reactive({
      kurtosis_log <- 50

      in_file <- input$expression_file
      in_file <- in_file$datapath

      if (is.null(input$expression_file) && input$go_button == 0) {
        return(NULL)
      }

      if (is.null(input$expression_file) && input$go_button > 0) {
        in_file <- idep_data$demo_data_file
      }

      tem <- input$data_file_format
      tem <- pre_process$missing_value()

      # These are needed to make it responsive to changes
      if (!is.null(input$data_file_format)) {
        if (input$data_file_format == 1) {
          tem <- pre_process$min_counts()
          tem <- pre_process$n_min_samples_count()
          tem <- pre_process$counts_log_start()
          tem <- pre_process$counts_transform()
        }
      }

      if (!is.null(input$data_file_format)) {
        if (input$data_file_format == 2) {
          tem <- pre_process$log_transform_fpkm()
          tem <- pre_process$log_start_fpkm()
          tem <- pre_process$low_filter_fpkm()
          tem <- pre_process$n_min_samples_fpkm()
        }
      }

      isolate({
        withProgress(message = "Reading and pre-processing ", {
          # these packages moved here to reduce loading time


          if (is.null(input$data_file_format)) {
            return(NULL)
          }
          data_type_warning <- 0
          data_type <- c(TRUE)

          # Read file ----------
          # CSV attempt
          data <- read.csv(in_file, quote = "", comment.char = "")

          # Tab-delimented if not CSV
          if (dim(data)[2] <= 2) {
            data <- read.table(
              in_file,
              sep = "\t",
              header = TRUE,
              quote = "",
              comment.char = ""
            )
          }

          # Remove non-numeric vars, except the first column -------
          for (i in 2:dim(data)[2]) {
            data_type <- c(data_type, is.numeric(data[, i]))
          }
          if (sum(data_type) <= 2) {
            return(NULL)
          }
          data <- data[, data_type] # only keep numeric columns

          # rows with all missing values
          missing_filter <- which(
            apply(
              data[, -1],
              1,
              function(y) {
                sum(is.na(y))
              }
            ) != dim(data)[2] - 1
          )
          data <- data[missing_filter, ]

          data_size_original <- dim(data)
          data_size_original[2] <- data_size_original[2] - 1
          data[, 1] <- toupper(data[, 1])
          data[, 1] <- gsub(" |\"|\'", "", data[, 1])
          # remove spaces in gene ids
          # remove " in gene ids, mess up SQL query
          # remove ' in gene ids
          # remove one or two digits after "." at the end.
          # A35244.1 -> A35244  or A35244.23 -> A35244, but not more than two.
          # GLYMA.18G52160 stays the same.

          # Sort by standard deviation -----------
          data <- data[order(-apply(
            data[, 2:dim(data)[2]],
            1,
            sd
          )), ]

          # Remove duplicated genes ----------
          data <- data[!duplicated(data[, 1]), ]
          rownames(data) <- data[, 1]
          data <- as.matrix(data[, c(-1)])

          # remove "-" or "." from sample names ----------
          colnames(data) <- gsub("-", "", colnames(data))
          colnames(data) <- gsub("\\.", "", colnames(data))

          # Missng value in data ----------
          if (sum(is.na(data)) > 0) {
            if (pre_process$missing_value() == "geneMedian") {
              row_medians <- apply(data, 1, function(y) median(y, na.rm = T))
              for (i in 1:dim(data)[2]) {
                val_miss_row <- which(is.na(data[, i]))
                data[val_miss_row, i] <- row_medians[val_miss_row]
              }
            } else if (pre_process$missing_value() == "treatAsZero") {
              data[is.na(data)] <- 0
            } else if (pre_process$missing_value() == "geneMedianInGroup") {
              sample_groups <- detect_groups(colnames(data))
              for (group in unique(sample_groups)) {
                samples <- which(sample_groups == group)
                row_medians <- apply(
                  data[, samples, drop = F],
                  1,
                  function(y) median(y, na.rm = T)
                )
                for (i in samples) {
                  missing <- which(is.na(data[, i]))
                  if (length(mssing) > 0) {
                    data[missing, i] <- row_medians[misssing]
                  }
                }
              }
              if (sum(is.na(data)) > 0) {
                row_medians <- apply(
                  data,
                  1,
                  function(y) median(y, na.rm = T)
                )
                for (i in 1:dim(data)[2]) {
                  missing <- which(is.na(data[, i]))
                  data[missing, i] <- row_medians[missing]
                }
              }
            }
          }

          # Compute kurtosis ---------
          mean_kurtosis <- mean(apply(data, 2, e1071::kurtosis), na.rm = T)
          raw_counts <- NULL
          pvals <- NULL
          if (input$data_file_format == 2) {
            incProgress(1 / 3, "Pre-processing data")
            if (is.integer(data)) data_type_warning <- 1

            # Filters ----------

            # Not enough counts
            data <- data[which(apply(
              data,
              1,
              function(y) sum(y >= pre_process$low_filter_fpkm())
            ) >= input$n_min_samples_fpkm), ]

            # Same levels in every entry
            data <- data[which(apply(
              data,
              1,
              function(y) max(y) - min(y)
            ) > 0), ]

            # Takes log if log is selected OR kurtosis is bigger than 50
            if (
              (pre_process$log_transform_fpkm() == TRUE) |
                (mean_kurtosis > kurtosis_log)) {
              data <- log(data + abs(pre_process$log_start_fpkm()), 2)
            }

            std_dev <- apply(data, 1, sd)
            data <- data[order(-std_dev), ]
          } else if (input$data_file_format == 1) {
            incProgress(1 / 3, "Pre-processing counts data")
            tem <- pre_process$counts_deg_method()
            tem <- pre_process$counts_transform()

            if (!is.integer(data) & mean_kurtosis < kurtosis_log) {
              data_type_warning <- -1
            }

            data <- round(data, 0)

            data <- data[which(apply(
              edgeR::cpm(edgeR::DGEList(counts = data)),
              1,
              function(y) sum(y >= pre_process$min_counts())
            ) >=
              pre_process$n_min_samples_count()), ]

            raw_counts <- data # ???
            browser()

            # Construct DESeqExpression Object
            tem <- rep("A", dim(data)[2])
            tem[1] <- "B"
            col_data <- cbind(colnames(data), tem)
            colnames(col_data) <- c("sample", "groups")
            dds <- DESeq2::DESeqDataSetFromMatrix(
              countData = data,
              colData = col_data,
              design = ~groups
            )
            dds <- DESeq2::estimateSizeFactors(dds)

            incProgress(1 / 2, "transforming raw counts")

            # Counts Transformation ------------
            if (pre_process$counts_transform() == 3) {
              data <- DESeq2::rlog(dds, blind = TRUE)
              data <- SummarizedExperiment::assay(data)
            } else if (pre_process$counts_transform() == 2) {
              data <- DESeq2::vst(dds, blind = TRUE)
              data <- SummarizedExperiment::assay(data)
            } else {
              data <- log2(BiocGenerics::counts(
                dds,
                normalized = TRUE
              ) + pre_process$counts_log_start())
            }
          } else if (input$data_file_format == 3) {
            n2 <- (dim(data)[2] %/% 2)
            if (!input$no_fdr) {
              pvals <- data[, 2 * (1:n2), drop = FALSE]
              data <- data[, 2 * (1:n2) - 1, drop = FALSE]
              if (dim(data)[2] == 1) {
                placeholder <- rep(1, dim(data)[1])
                pvals <- cbind(pvals, placeholder)
                zero_placeholder <- rep(0, dim(data)[1])
                data <- cbind(data, zero_placeholder)
              }
            }
          }

          data_size <- dim(data)

          validate(
            need(
              dim(data)[1] > 5 & dim(data)[2] >= 1,
              "Data file not recognized. Please double check."
            )
          )

          incProgress(1, "Done.")

          sample_info_demo <- NULL

          if (input$go_button > 0) {
            sample_info_demo <- t(read.csv(
              idep_data$demo_metadata_file,
              row.names = 1,
              header = T,
              colClasses = "character"
            ))
          }

          final_result <- list(
            data = as.matrix(data),
            mean_kurtosis = mean_kurtosis,
            raw_counts = raw_counts,
            data_type_warning = data_type_warning,
            data_size = c(data_size_original, data_size),
            sample_info_demo = sample_info_demo,
            pvals = pvals
          )

          return(final_result)
        })
      })
    })

    read_sample_info <- reactive({
      if (is.null(input$expression_file) &&
        !is.null(read_data()$sample_info_demo)) {
        return(read_data()$sample_info_demo)
      }
      in_file <- input$experiment_file
      in_file <- in_file$datapath

      if (is.null(input$experiment_file) && input$go_button == 0) {
        return(NULL)
      }
      if (is.null(read_data())) {
        return(NULL)
      }

      isolate({
        if (is.null(input$data_file_format)) {
          return(NULL)
        }

        data_type_warning <- 0
        data_type <- c(TRUE)

        # Read experiment file ----------
        expr <- read.csv(
          in_file,
          row.names = 1,
          header = TRUE,
          colClasses = "character"
        )
        if (dim(expr)[2] <= 2) {
          expr <- read.table(
            in_file,
            row.names = 1,
            sep = "\t",
            header = TRUE,
            colClasses = "character"
          )
        }

        # remove "-" or "." from sample names ----------
        colnames(expr) <- gsub("-", "", colnames(expr))
        colnames(expr) <- gsub("\\.", "", colnames(expr))

        # Matching with column names of expression file ----------
        matches <- match(
          toupper(colnames(read_data()$data)), toupper(colnames(expr))
        )
        matches <- matches[which(!is.na(matches))] # remove NA

        validate(need(
          length(unique(matches)) == dim(read_data()$data)[2] &
            dim(expr)[1] >= 1 & dim(expr)[1] < 500,
          "Error!!! Sample information file not recognized. Sample names
           must be exactly the same. Each row is a factor. Each column
           represent a sample.  Please see documentation on format."
        ))

        # Check factor levels, change if needed ----------
        for (i in 1:dim(expr)[1]) {
          expr[i, ] <- gsub("-", "", expr[i, ])
          expr[i, ] <- gsub("\\.", "", expr[i, ])
        }

        # Factor levels match ----------
        if (length(unique(matches)) == dim(read_data()$data)[2]) {
          expr <- expr[, matches]

          if (
            sum(apply(expr, 1, function(y) length(unique(y)))) >
              length(unique(unlist(expr)))) {
            factor_names <- apply(
              expr,
              2,
              function(y) paste0(names(y), y)
            )
            rownames(factor_names) <- rownames(expr)
            expr <- factor_names
          }
          return(t(expr))
        } else {
          return(NULL)
        }
      })
    })